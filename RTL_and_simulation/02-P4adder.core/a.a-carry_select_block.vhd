library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use work.constants.all;


entity CSB is
  generic(NBIT: natural := numBitP4);
  port(A,B: in std_logic_vector(NBIT-1 downto 0);
       Cin: in std_logic;
       --Cout: out std_logic;
       -- The carry-out is not useful since the carries
       -- are generated by an external logic
       Sum: out std_logic_vector(NBIT-1 downto 0));
end CSB;

architecture STRUCTURAL of CSB is
  component RCA is -- Ripple Carry Adder
	generic (NBIT  :        natural := numBitP4);
	Port (A:	In	std_logic_vector(NBIT-1 downto 0);
		B:	In	std_logic_vector(NBIT-1 downto 0);
		Ci:	In	std_logic;
		S:	Out	std_logic_vector(NBIT-1 downto 0);
		Co:	Out	std_logic);
  end component;

  component MUX21_GENERIC is
	Generic (NBIT: natural:= numBitP4);  
	Port (	A:	In	std_logic_vector(NBIT-1 downto 0);
		B:	In	std_logic_vector(NBIT-1 downto 0);
		S:	In	std_logic;
		Y:	Out	std_logic_vector(NBIT-1 downto 0));
  end component;

  -- Internal signals
  signal Sum0_to_mux,Sum1_to_mux: std_logic_vector(NBIT-1 downto 0);

  -- Dummy carry-out of the two RCAs
  signal Co0,Co1: std_logic;
begin
  
  RCA0: RCA generic map (NBIT => NBIT) 
    port map(A=>A,B=>B,Ci=>'0',S=>Sum0_to_mux,Co=>Co0); 
  -- RCA carry-out cannot be forced to ground
  -- The carry-outs are left floating in this description

  RCA1: RCA generic map (NBIT => NBIT) 
    port map(A=>A,B=>B,Ci=>'1',S=>Sum1_to_mux,Co=>Co1);

  MUX21: MUX21_GENERIC generic map (NBIT => NBIT) 
    port map(A=>Sum1_to_mux,B=>Sum0_to_mux,S=>Cin,Y=>Sum);

end STRUCTURAL;

configuration CFG_CSB_STRUCTURAL of CSB is
  for STRUCTURAL
    for RCA0: RCA
      use configuration work.CFG_RCA_STRUCTURAL;
    end for;
    for RCA1 : RCA
      use configuration work.CFG_RCA_STRUCTURAL;
    end for;
    for MUX21: MUX21_GENERIC
      use configuration work.CFG_MUX21_BEHAVIORAL;
    end for;
  end for;
end CFG_CSB_STRUCTURAL;
